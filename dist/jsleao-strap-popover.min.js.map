{"version":3,"sources":["helpers/dimensions.js","popover/popover.js","tooltip/tooltip.js"],"names":[],"mappings":"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","file":"jsleao-strap-popover.min.js","sourcesContent":["'use strict';\n\nangular.module('jsleao.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function($document, $window) {\n\n    var jqLite = angular.element;\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function(element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function(element, prop, extra) {\n      var value;\n      if (element.currentStyle) { //IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function(element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function(element) {\n\n      var offsetParentRect = {top: 0, left: 0},\n          offsetParentElement,\n          offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentElement\n        offsetParentElement = offsetParent(element);\n        offset = fn.offset(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentElement, 'html')) {\n          offsetParentRect = fn.offset(offsetParentElement);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentElement, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentElement, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    var offsetParent = function offsetParentElement(element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if(nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while(offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    };\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function(element, outer) {\n      var value = element.offsetHeight;\n      if(outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function(element, outer) {\n      var value = element.offsetWidth;\n      if(outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('jsleao.ngStrap.popover', ['jsleao.ngStrap.tooltip'])\n\n  .provider('$popover', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      container: false,\n      target: false,\n      placement: 'right',\n      template: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0\n    };\n\n    this.$get = function($tooltip) {\n\n      function PopoverFactory(element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if(options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'customClass'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function(key) {\n          attr[key] && attr.$observe(key, function(newValue, oldValue) {\n            scope[key] = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && requestAnimationFrame(function() {\n              popover && popover.$applyPlacement();\n            });\n          });\n        });\n\n        // Support scope as an object\n        attr.bsPopover && scope.$watch(attr.bsPopover, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.content = newValue;\n          }\n          angular.isDefined(oldValue) && requestAnimationFrame(function() {\n            popover && popover.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!popover || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n          newValue === true ? popover.show() : popover.hide();\n        });\n\n        // Initialize popover\n        var popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('jsleao.ngStrap.tooltip', ['jsleao.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, dimensions, $$rAF) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Support scope as string options\n        if(options.title) {\n          $tooltip.$scope.title = options.title;\n        }\n\n        // Provide scope helpers\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n\n          // Remove element\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = null;\n          }\n\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent = options.container ? tipContainer : null;\n          var after = options.container ? null : element;\n\n          // Hide any existing tipElement\n          if(tipElement) tipElement.remove();\n          // Fetch a cloned element linked from template\n          tipElement = $tooltip.$element = tipLinker(scope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'}).addClass(options.placement);\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          if(promise && promise.then) promise.then(enterAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n          $$rAF(function () {\n            $tooltip.$applyPlacement();\n\n            // Once placed, make the tooltip visible\n            tipElement.css({visibility: 'visible'});\n          }); // var a = bodyEl.offsetWidth + 1; ?\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n              tipElement.on('keyup', $tooltip.$onKeyUp);\n            } else {\n              element.on('keyup', $tooltip.$onFocusKeyUp);\n            }\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // Support v1.3+ $animate\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\n\n          $tooltip.$isShown = scope.$isShown = false;\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          }\n\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          // Allow to blur the input when hidden, like when pressing enter key\n          if(blur && options.trigger === 'focus') {\n            return element[0].blur();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Get the position of the tooltip element.\n          var elementPosition = getPosition();\n\n          // Get the height and width of the tooltip so we can center it.\n          var tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(options.placement, elementPosition, tipWidth, tipHeight);\n\n          // Now set the calculated positioning.\n          tipPosition.top += 'px';\n          tipPosition.left += 'px';\n          tipElement.css(tipPosition);\n\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // Private methods\n\n        function getPosition() {\n          if(options.container === 'body') {\n            return dimensions.offset(options.target[0] || element[0]);\n          } else {\n            return dimensions.position(options.target[0] || element[0]);\n          }\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      function fetchTemplate(template) {\n        return $q.when($templateCache.get(template) || $http.get(template))\n        .then(function(res) {\n          if(angular.isObject(res)) {\n            $templateCache.put(template, res.data);\n            return res.data;\n          }\n          return res;\n        });\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'type', 'customClass'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}